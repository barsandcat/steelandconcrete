<HTML>
<HEAD>
<TITLE>System Abstraction Layer</TITLE>
<UL>
<LI> <A HREF = "#introduction">Introduction</A>
<LI> <A HREF = "#mutlitasking">Multitasking</A>
   <UL>
   <LI> <A HREF = "#task">task</A>
       <UL>
       <LI> <A HREF = "#create">create</A>
       <LI> <A HREF = "#initialize">initialize</A>
       <LI> <A HREF = "#reschedule">reschedule</A>
       <LI> <A HREF = "#sleep">sleep</A>
       <LI> <A HREF = "#exit">exit</A>
       <LI> <A HREF = "#current">current</A>
       <LI> <A HREF = "#create">create</A>
       </UL>
   <LI> <A HREF = "#mutex">mutex</A>
       <UL>
       <LI> <A HREF = "#enter">enter</A>
       <LI> <A HREF = "#leave">leave</A>
       </UL>
   <LI> <A HREF = "#critical_section">critical_section</A>
   <LI> <A HREF = "#semaphore">semaphore</A>
       <UL>    
       <LI> <A HREF = "#sem_wait">wait</A>
       <LI> <A HREF = "#sem_wait_with_timeout">wait_with_timeout</A>
       <LI> <A HREF = "#sem_signal">signal</A>
       </UL>
   <LI> <A HREF = "#semaphorex">semaphorex</A>
   <LI> <A HREF = "#event">event</A>
       <UL>    
       <LI> <A HREF = "#event_wait">wait</A>
       <LI> <A HREF = "#event_wait_with_timeout">wait_with_timeout</A>
       <LI> <A HREF = "#event_signal">signal</A>
       <LI> <A HREF = "#event_reset">reset</A>
       </UL>
   <LI> <A HREF = "#eventex">eventex</A>
   <LI> <A HREF = "#fifo_queue">fifo_queue</A>
       <UL>    
       <LI> <A HREF = "#is_empty">is_empty</A>
       <LI> <A HREF = "#is_full">is_full</A>
       <LI> <A HREF = "#get">operator &lt;&lt; </A>
       <LI> <A HREF = "#put">operator &gt;&gt; </A>
       </UL>
   <LI> <A HREF = "#barrier">barrier</A>
       <UL>    
       <LI> <A HREF = "#reset">reset</A>
       <LI> <A HREF = "#reach">reach</A>
       </UL>
   <LI> <A HREF = "#debugging">Debugging multitasking application</A>
   </UL>
<LI> <A HREF = "#files">Files</A>
   <UL>
   <LI> <A HREF = "#os_file">os_file</A>
       <UL>
       <LI> <A HREF = "#readcur">read from current position</A>
       <LI> <A HREF = "#read">read from specified position</A>
       <LI> <A HREF = "#writecur">write to current position</A>
       <LI> <A HREF = "#write">write to specified position</A>
       <LI> <A HREF = "#set_position">set_position</A>
       <LI> <A HREF = "#get_position">get_position</A>
       <LI> <A HREF = "#flush">flush</A>
       <LI> <A HREF = "#open">open</A>
       <LI> <A HREF = "#close">close</A>
       <LI> <A HREF = "#get_name">get_name</A>
       <LI> <A HREF = "#set_name">set_name</A>
       <LI> <A HREF = "#get_size">get_size</A>
       <LI> <A HREF = "#set_size">set_size</A>
       <LI> <A HREF = "#get_error_text">get_error_text</A>
       </UL>
   <LI> <A HREF = "#mmap_file">mmap_file</A>
   <LI> <A HREF = "#multifile">multifile</A>
   </UL>
<LI> <A HREF = "#sockets">Sockets</A>
   <UL>
   <UL>
   <LI> <A HREF = "#sock_read">read</A>
   <LI> <A HREF = "#sock_write">write</A>
   <LI> <A HREF = "#accept">accept</A>
   <LI> <A HREF = "#cancel_accept">cancel_accept</A>
   <LI> <A HREF = "#shutdown">shutdown</A>
   <LI> <A HREF = "#sock_close">close</A>
   <LI> <A HREF = "#connect">sock_close</A>
   <LI> <A HREF = "#create_global">create_global</A>
   <LI> <A HREF = "#create_local">create_local</A>
   <LI> <A HREF = "#is_ok">is_ok</A>
   <LI> <A HREF = "#sock_get_error_text">get_error_text</A>
   </UL>
   </UL>
<LI> <A HREF = "#console">Console</A>
   <UL>
   <UL>
   <LI> <A HREF = "#output">output</A>
   <LI> <A HREF = "#error">error</A>
   <LI> <A HREF = "#input">input</A>
   <LI> <A HREF = "#output_data">output_data</A>
   <LI> <A HREF = "#input_data">input_data</A>
   </UL>
   </UL>
<LI> <A HREF = "#distribution">Distribution</A>
</UL>
   

<BODY>
<HR>

<H2><A NAME = "introduction">Introduction</A></H2>
If you are going to make your application portable it is necessary to 
isolate system dependent code in few modules. In this case migration
to new platform/operating system will require only changing these
system dependent modules and not affecting other application code.  
This library provides abstraction of operating system services to
application, so the application can use the same calls under Unix and 
Windows systems for example.<P>

Current version of SAL library provides abstraction of three subsystems:
multitasking, file IO and socket IO. Implementations of this interfaces for
Windows 95/98/NT and various versions of Unix are currently available.
This library was primary developed for GOODS project 
(multiplatform distributed Generic Object Orient Database 
management System) and proved to be effective solution for development 
of portable application.<P>

Depending on requirements to the subsystem, three different approaches 
are used for for encapsulation of system dependent implementation for these
interfaces:<P>

<TABLE BORDER ALIGN="CENTER">
<TR><TH>Subsystem</TH><TH>Approach</TH></TR>
<TR><TD>Multitasking</TD><TD>Conditional inheritance</TD></TR>
<TR><TD>File IO</TD><TD>Different method implementations</TD></TR>
<TR><TD>Socket IO</TD><TD>Abstract class with several implementation classes
</TD></TR></TABLE><P>
 
<H2> <A NAME = "multitasking">Multitasking</A></H2>
Modern applications are used to have several threads of control - do
some work in parallel. Multithreaded model of application proved to be
the most efficient and convenient way for writing concurrent applications
(comparing with old schemes, like signals, ASTs, interprocess communication).
Multithreaded model is especially good for client/server model where one server
has to serve several clients at the same time.<P>
 
Abstraction of thread is represented in SAL by class <code>task</code>
(name <I>thread</I> was not used to avoid name conflict). 
Except <code>task</code> class, multitasking subsystem provides set of
synchronization classes, which make possible to synchronize execution of
concurrent tasks.<P>
 
Multitasking interface requires high effective inline implementations for 
critical sections
(since this operations are very frequently used in multithreaded applications).
That is why <I>conditional inheritance</I> was used for the classes 
representing synchronization primitives. Each such class <I>XXX</I> is 
derived from correspondent <I>XXX_internals</I> class, which methods are 
invoked by inline methods of interface class <I>XXX</I>.
Implementation of internal classes depends on the system
and is taken from one of the available header files. Currently
three different implementations of multitasking subsystem are provided:<P>

<OL>
<LI>Portable cooperative multitasking implementation based on C 
<code>setjmp()/longjmp()</code> functions
<LI>Multitasking implementation based on Posix threads (available in most modern Unix systems)
<LI>Implementation for Windows family based on Win32 interface  
</OL>

Portable implementation provides cooperative model of multitasking
(rescheduling of tasks should be done explicitly). Multitasking model of two
other implementations depends on type of multitasking supported by
concrete operating system for system threads. In most cases it is 
preemptive model of multitasking - processor can be rescheduled
at any moment of time. Portable implementation provides asynchronous
operations with sockets, but not with files (so all read/write file
operations are synchronous and blocks all tasks within process). 
But as far as all control
of multitasking in portable version is done at user library level
and requires no system calls, at single processor platform it provides the 
highest performance comparing with implementation using kernel threads.
Most of implementations of Posix threads use two level model combining 
user and kernel threads. In this case arbitrary number of user
threads can be implemented on base of pool of several kernel threads.
Kernel is responsible for scheduling of kernel threads, while
pthread library performs scheduling of user threads between these kernel
threads. But, for example at Digital Unix, experiments show that
with single CPU, portable multitasking implementation provides significant
benefit in performance, comparing with pthreads implementation.<P>


<H3> <A NAME = "task">task</A></H3>

<HR>

<A NAME = "create"><pre>
static task* create(fptr f, void* arg = NULL, priority pri = pri_normal, 
 	            size_t stack_size = normal_stack); 
</pre></A>
<DL><DD>
Create new task. Pointer to task object, returned by this function,
can be used only for task identification. 
<DL>
<DT><B>Parameters</B>
<DD><code>f</code> - pointer to function to be executed in new task.
<DD><code>arg</code> - argument which should be passed to the function
<DD><code>priority</code> - one of the following task priorities: 
pri_background, pri_low, pri_normal, pri_high, pri_realtime.
<DD><code>stack_size</code> - space reserved for task stack. You can specify
any value not smaller than min_stack. Also the following
symbolic links are provided:<P>

<TABLE BORDER ALIGN="CENTER">
<TR><TH>Name</TH><TH>Value</TH></TR>
<TR><TD>min_stack</TD><TD>    8  Kb</TD></TR> 
<TR><TD>small_stack</TD><TD>  16 Kb</TD></TR>
<TR><TD>normal_stack</TD><TD> 64 Kb</TD></TR>
<TR><TD>big_stack</TD><TD>    256 Kb</TD></TR>
<TR><TD>huge_stack</TD><TD>   1024 Kb</TD></TR>
</TABLE><P>

<DT><B>Returns</B>
<DD>Task identifier, which can be used to compare with identifier of current
task returned by <A HREF="#current"><code>task::current()</code></A> method
</DL></DL>


<HR>
<A NAME = "initialize"><pre>
static void initialize(size_t main_stack_size = normal_stack);
</pre></A>
<DL><DD>
Initialize multitasking library and create initial task.
Invocation of this method should be the first statement of <code>main()</code>
procedure. Using multitasking library without initialization can cause
unpredictable behavior. 
<DL>
<DT><B>Parameters</B>
<DD><code>main_stack_size</code> - specify stack size reserved for main task.
This parameter is used only by portable multitasking implementation.
</DL></DL>

<HR>
<A NAME = "reschedule"><pre>
static void reschedule();
</pre></A>
<DL><DD>
Force task rescheduling. It is necessary to call this method only with
cooperative multitasking scheme (portable implementation). But even with
cooperative multitasking there are only few situations when programmer
has to call this function. 
</DL>

<HR>
<A NAME = "sleep"><pre>
static void sleep(timeout_t msec);
</pre></A>
<DL><DD>
Suspend execution of current task for specified period of time.
<DL>
<DT><B>Parameters</B>
<DD><code>msec</code> - value of timeout in milliseconds
</DL></DL>

<HR>
<A NAME = "exit"><pre>
static void exit();
</pre></A>
<DL><DD>
Exit current task. Task is terminated when either <code>exit()</code>
method is called or return from task function is done.
</DL>

<HR>
<A NAME = "current"><pre>
static void current();
</pre></A>
<DL><DD>
Get identifier of the current task.
<DL>
<DT><B>Returns</B>
<DD>Identifier of the current task.
</DL></DL>


<H3> <A NAME = "mutex">mutex</A></H3>
Mutex is basic synchronization primitive providing mutual exclusion
of several concurrent tasks. Only one task can own the mutex each moment of 
time. So mutexes can be used to guard critical section from concurrent access.
<P>

<HR>
<A NAME = "enter"><pre>
void enter();
</pre></A>
<DL><DD>
Make the current task an owner of the mutex. If some other task owns the 
mutex at this moment, calling task will wait until first task release the 
mutex. The task can invoke <code>enter</code> method several times and mutex
will be released only after correspondent number of <code>leave</code> 
invocations.
</DL>

<HR>
<A NAME = "leave"><pre>
void leave();
</pre></A>
<DL><DD>
Release the mutex if number of <code>enter()</code> invocations becomes equal
to the number of <code>leave()</code> invocations.
</DL>


<H3> <A NAME = "critical_section">critical_section</A></H3>

This class provides convenient way of protecting block of code
(critical section) from concurrent access. If automatic object 
(local variable) of this class is created on stack as first statement of the 
block, constructor of this object will lock attached mutex object and
destructor of the object will release it after exiting from the block
(normal or as a result of exception).<P> 

<HR>
<pre>
critical_section(mutex& guard);
</pre></A>
<DL><DD>
Lock specified mutex object.
<DL>
<DT><B>Parameters</B>
<DD><code>guard</code> - mutex used to synchronize access to this critical 
section
</DL></DL>


<H3> <A NAME = "semaphore">semaphore</A></H3>
This class provides implementation of classical Dijkstra semaphore with
wait and signal operations. Semaphore usually are used to manage access to
some fixed amount of resource.<P> 

<HR>
<A NAME = "sem_wait"><pre>
void wait();
</pre></A>
<DL><DD>
Block current task until semaphore counter becomes non-zero. 
Then conunter is decremented by 1 and execution of the task will continue.  
</DL>

<HR>
<A NAME = "sem_wait_with_timeout"><pre>
boolean wait_with_timeout(timeout_t msec) { 
</pre></A>
<DL><DD>
Block current task until semaphore counter becomes non-zero or 
specified timeout is expired. 
<DL>
<DT><B>Parameters</B>
<DD><code>msec</code> - value of timeout in milliseconds. If zero
timeout parameter is specified the method will return immediately.
<DT><B>Returns</B>
<DD><code>True</code> if value of counter is non-zero, <code>False</code>
if timeout is expired before semaphore is signaled. 
</DL></DL>

<HR>
<A NAME = "sem_signal"><pre>
void signal();
</pre></A>
<DL><DD>
This method increments by one semaphore counter. If there are one or more
tasks waiting for this semaphore, exactly one of them (task waiting
the longest time) will be awaken. 
</DL>

<H3> <A NAME = "semaphorex">semaphorex</A></H3>
If process in critical section (owning some mutex) has to wait for semaphore,
it should first release the mutex, wait until semaphore will be signaled
and then reestablish ownership on the mutex. The problem is that in the 
interval after releasing mutex and sleeping at semaphore or after task 
awakening and locking mutex, another process can enter 
critical section and use the resource, which was indented for this task.
To avoid such situation, special kind of semaphore was proposed: 
semaphore guarded by mutex. All operations with such semaphore should
be done with the associated mutex locked. When a task sleeps at semaphore,
it unlocks guarded mutex, and when the task is awaken by signaling semaphore -
it reestablish ownership of the guard mutex. These operation are done
atomically: it means that no other task can lock this mutex between
the moment of task awakening and reentering the critical section.<P>

This class has the same methods as <code>semaphore</code> class.
Result of executing method of this class with unlocked guard mutex or
with mutex locked more than once (nested locks) is unpredictable.
Portable multitasking library is able to catch such errors by 
<code>assert</code>
statement, but the same is not true for implementation based on OS threads.
This class provides the same model of accessing conditional variables
as used in Posix threads.<P>


<HR>
<pre>
semaphores(mutex& guard);
</pre></A>
<DL><DD>
Associate mutex with semaphore object.
<DL>
<DT><B>Parameters</B>
<DD><code>guard</code> - mutex to be used as semaphore guard.
</DL></DL>


<H3> <A NAME = "event">event</A></H3>
Event is simple synchronization object similar with conditional
variable or event flag. It can be set in signaled state and will be
left in this state until it is explicitly reset (in Win32 such object is
called event with manual reset).<P> 

<HR>
<A NAME = "event_wait"><pre>
void wait();
</pre></A>
<DL><DD>
If event is not in signaled state, then block current task until some
other task will signal the event. 
</DL>

<HR>
<A NAME = "event_wait_with_timeout"><pre>
boolean wait_with_timeout(timeout_t msec) { 
</pre></A>
<DL><DD>
Wait within specified period of time until event will be signaled,
<DL>
<DT><B>Parameters</B>
<DD><code>msec</code> - value of timeout in milliseconds. If zero
timeout parameter is specified the method will return immediately.
<DT><B>Returns</B>
<DD><code>True</code> if event is signaled, <code>False</code>
if timeout is expired before event is set to signaled state. 
</DL></DL>

<HR>
<A NAME = "event_signal"><pre>
void signal();
</pre></A>
<DL><DD>
Set event to the signaled state, All tasks waiting for this event are
awaken. The event will remain in signal state until <A HREF="#reset">
<code>reset()</code></A> method will be called.
</DL>


<HR>
<A NAME = "event_reset"><pre>
void reset();
</pre></A>
<DL><DD>
Reset event to non-signaled state.
</DL>


<H3> <A NAME = "eventex">eventex</A></H3>
Event guarded by mutex. Method <code>wait()</code> atomically releases
mutex and blocks calling task until event will be signaled.
After return the mutex has been locked and is owned by the current task.
This class has the same methods as <code>event</code> class.
Result of executing method of this class with unlocked guard mutex or
with mutex locked more than once (nested locks) is unpredictable.<P>

<HR>
<pre>
eventex(mutex& guard);
</pre></A>
<DL><DD>
Associate mutex with event object.
<DL>
<DT><B>Parameters</B>
<DD><code>guard</code> - mutex to be used as event guard.
</DL></DL>



<H3> <A NAME = "fifo_queue">fifo_queue</A></H3>
Template class <code>fifo_queue</code> can be used as communication buffer 
between two or more tasks. Such models of intertask communications as 
producer/consumers and channels can be implemented by means of this class.
This class uses cyclic buffer which size is determined at the moment
of object creation.<P> 

<HR>
<pre>
fifo_queue(size_t size);
</pre></A>
<DL><DD>
Construct queue with specified size of cyclic buffer.
<DL>
<DT><B>Parameters</B>
<DD><code>size</code> - cyclic buffer size. When <code>size</code> elements are
put into the queue, it become full and any other attempt to add element to the 
queue will block the calling task.
</DL></DL>

<HR>
<A NAME = "is_empty"><pre>
boolean is_empty() const;
</pre></A>
<DL><DD>
Checks if there are available elements in queue.
<DL>
<DT><B>Returns</B>
<DD><code>True</code> if there are no elements in queue; <code>False</code>
otherwise. 
</DL></DL>

<HR>
<A NAME = "is_full"><pre>
boolean is_full() const;
</pre></A>
<DL><DD>
Checks if more elements can be placed in queue. 
<DL>
<DT><B>Returns</B>
<DD><code>True</code> if cyclic buffer is full (no more elements can be placed 
in the queue until some elements were taken from it); <code>False</code>
otherwise. 
</DL></DL>

<HR>
<A NAME = "put"><pre>
fifo_queue& operator &lt;&lt (T const& elem);
</pre></A>
<DL><DD>
Put new element is queue. This method will block current task if queue 
is full (if there is no free space in cyclic buffer).
<DL>
<DT><B>Parameters</B>
<DD><code>elem</code> - element to be inserted in queue.
<DT><B>Returns</B>
<DD>Reference to <code>this</code> object to make it possible to use chain of 
<code>&lt;&lt</code> operations.
</DL></DL>

<HR>
<A NAME = "get"><pre>
fifo_queue& operator &gt;&gt (T& elem);
</pre></A>
<DL><DD>
Get element from the queue. This method will block current task if queue 
is empty (if there are no elements in queue).
<DL>
<DT><B>Parameters</B>
<DD><code>elem</code> - reference to location where extracted element should be
placed.
<DT><B>Returns</B>
<DD>Reference to <code>this</code> object to make it possible to use chain of 
<code>&gt;&gt</code> operations.
</DL></DL>


<H3> <A NAME = "barrier">barrier</A></H3>
A <code>barrier</code> class allows a set of tasks to sync up at some point in
their code. It is initialized to the number of tasks to be using it, then it 
blocks all tasks calling it until it reaches zero, at which point it unblocks 
them all. The idea is that you can now arrange for a set of tasks to stop when
they get to some predefined point in their computation and wait for all others
to catch up. If you have eight tasks, you initialize the barrier to eight. 
Then, as each task reaches that point, it decrements the barrier, and hence 
goes to sleep. When the last task arrives, it decrement the barrier to zero, 
and they all unblock and proceed.<P>

<HR>
<A NAME = "reset"><pre>
void reset(int n);
</pre></A>
<DL><DD>
Initialize the barrier object.
<DL>
<DT><B>Parameters</B>
<DD><code>n</code> - number of tasks using this barrier for synchronization.
</DL></DL>

<HR>
<A NAME = "reach"><pre>
void reach();
</pre></A>
<DL><DD>
Decrement barrier value. If barrier value is positive after decrement
operation, then block calling task otherwise unblock all tasks reached the
barrier.
</DL>


<H3> <A NAME = "debugging">Debugging multitasking applications</A></H3>
Debugging of multitasking applications is very difficult task because
non-deterministic program behavior and presence of several concurrent 
threads of control. A number of things can go wrong when you try to coordinate
the interactions of concurrent tasks. The most popular bugs are 
<I>race condition</I> when you forget to synchronize access to common 
variables, and <I>deadlocks</I> when two or more tasks mutually lock
each other.<P>

Most of the systems supporting multithreaded model have
debugger which is able to deal with threads (suspend/resume threads, 
switch between threads, show thread context). As far as cooperative 
multitasking provided by SAL is not visible for the system and debugger, 
a number of special functions were implemented to make it possible
to debug such applications using standard debugger (debugger should support
evaluation of user functions). The following section describes these functions
and should be read only if you are going to use portable multitasking 
implementation. My experiments with this library shows that is more convenient
to start debugging of the application with cooperative multitasking and then 
switch to preemptive multitasking.<P>

To enable debugging of application using cooperative multitasking provided
by SAL, you should compile SAL sources with 
<code>CTASK_DEBUGGING_SUPPORT</code> macro defined.
As far as defining this name adds very small runtime overhead, it is
defined by default. If this macro is defined three functions will be available
in SAL library, which can be used for analyzing state of multitasking program
(unfortunately it is not possible to continue execution after such analysis).
<P>


<HR>
void debug_get_number_of_tasks();
</pre></A>
<DL><DD>
Get number of tasks in application.
<DL>
<DT><B>Returns</B>
<DD>The number of tasks in application (active, waiting or sleeping).
</DL></DL>


<HR>
void debug_catch_task_activation();
</pre></A>
<DL><DD>
You should set breakpoint to this functions to see context of the task.
Idea of debugging multitasking applications by standard C debugger is very
simple: function <code>debug_select_task(int)</code> is used to switch 
context to specified task, and breakpoint in 
<code>debug_catch_task_activation()</code> make it possible to programmer 
to see this context.
</DL>


<HR>
void debug_select_task(int i);
</pre></A>
<DL><DD>
Switch context to specified task. Total number of active tasks in process
can be obtained by <code>debug_get_number_of_tasks()</code> function. 
Index of task passed as parameter to this function should be positive number 
less than value returned by <code>debug_get_number_of_tasks()</code>. 
Task with index 0 refers to the task, which was running before debugger 
stops the application, and it can not be activated with this function
(so always investigate current context before switching to other tasks).
After activation of the specified task, control is passed to the function 
<code>debug_catch_task_activation()</code> and then execution of the task 
continues.
<DL>
<DT><B>Parameter</B>
<DD><code>i</code> - index of the task, should be in range [1..number-of-tasks)
<DT><B>Returns</B>
<DD><code>-1</code> if specified number is greater or equal to the 
number of tasks in the application or less than 1. Otherwise control from this 
function will not return (longjmp). 
</DL></DL>



<H2> <A NAME = "files">Files</A></H2>
SAL library provides three different abstractions of files:<P>
<OL>
<LI><A HREF="#os_file">Abstraction of normal file</A>
<LI><A HREF="#mmap_file">Abstraction of mapped on memory file</A>
<LI><A HREF="#mulifile_file">Abstraction of file consisting of several physical segments</A>
</OL><P>

Because of presence of this abstract class hierarchy (all this classes
are derived from abstract class <code>file</code>), it is not convenient
to use inheritance to provide system dependent implementations. 
Instead of this several system dependent implementations of file class 
methods are provided and they are placed in two system dependent
modules <code>unifile.cxx</code> and <code>winfile.cxx</code>. 
This is possible because structure of the <code>file</code> class is 
almost the same for all systems, we need only to describe system
dependent handle type.<P>

<H3> <A NAME = "os_file">os_file</A></H3>
Class <code>os_file</code> provides standard set of methods 
for accessing operating system file.<P> 


<HR>
<pre>
os_file(const char* name);
</pre></A>
<DL><DD>
Create file object with specified name.
<DL>
<DT><B>Parameters</B>
<DD><code>name</code> - name of the file
</DL></DL>

<HR>
<A NAME="readcur"><pre>
iop_status read(void* buf, size_t size);
</pre></A>
<DL><DD>
Read specified number of bytes from the current position in the file.
File pointer is then incremented by number of really read bytes. 
<DL><DT><B>Parameter</B>
<DD><code>buf</code> - buffer to hold read data. The buffer size should be
not less than <code>size</code>.
<DD><code>size</code> - number of bytes to read
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD><code>end_of_file</code> if there are less than <code>size</code> bytes
between current position and end of file; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="read"><pre>
iop_status read(fposi_t pos, void* buf, size_t size);
</pre></A>
<DL><DD>
Read specified number of bytes from the specified position in the file.
Position of file pointer is not defined after this operation.
<DL><DT><B>Parameter</B>
<DD><code>pos</code> - position in the file
<DD><code>buf</code> - buffer to hold read data. The buffer size should be
not less than <code>size</code>.
<DD><code>size</code> - number of bytes to read
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD><code>end_of_file</code> if there are less than <code>size</code> bytes
between specified position and end of file; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="writecur"><pre>
iop_status write(void const* buf, size_t size);
</pre></A>
<DL><DD>
Write specified number of bytes to the current position in the file.
File pointer is then incremented by number of really written bytes, 
<DL><DT><B>Parameter</B>
<DD><code>buf</code> - buffer with data to be written.
<DD><code>size</code> - number of bytes to write
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD><code>end_of_file</code> if number of bytes really written is less than 
<code>size</code> bytes; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="write"><pre>
iop_status write(fposi_t pos, void const* buf, size_t size);
</pre></A>
<DL><DD>
Write specified number of bytes to the specified position in the file.
Position of file pointer is not defined after this operation.
<DL><DT><B>Parameter</B>
<DD><code>buf</code> - buffer with data to be written.
<DD><code>size</code> - number of bytes to write
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD><code>end_of_file</code> if number of bytes really written is less than 
<code>size</code> bytes; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="set_position"><pre>
iop_status set_position(fposi_t pos);
</pre></A>
<DL><DD>
Set current position in the file.
<DL><DT><B>Parameter</B>
<DD><code>pos</code> - position in the file
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="get_position"><pre>
iop_status get_position(fposi_t& pos);
</pre></A>
<DL><DD>
Get current position in the file.
<DL><DT><B>Parameter</B>
<DD><code>pos</code> - reference to variable to hold current position in the file
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD>any other system dependent code if operation failed.
</DL></DL>


<HR>
<A NAME="flush"><pre>
iop_status flush();
</pre></A>
<DL><DD>
Flush all modified file data on disk. After successful completion of this
method file data in system cache is guaranteed to be synchronized with
contents of the disk.
<DL><DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="open"><pre>
iop_status open(access_mode mode, int flags);
</pre></A>
<DL><DD>
Open the file in specified mode.
<DL><DT><B>Parameter</B>
<DD><code>mode</code> - one of <code>fa_read, fa_write, fa_readwrite</code>
<DD><code>flags</code> - combination of 0 or more flags:<P>
<TABLE BORDER ALIGN="CENTER">
<TR><TH>Flag</TH><TH>Description</TH></TR>
<TR><TD>fo_truncate</TD><TD>reset length of file to 0</TD></TR>
<TR><TD>fo_create</TD><TD>create file if not existed</TD></TR>
<TR><TD>fo_sync </TD><TD>wait completion of write operations</TD></TR>
<TR><TD>fo_random</TD><TD>optimize file for random access</TD></TR>
<TR><TD>fo_exclusive</TD><TD>prevent file from opening by another process</TD></TR>
<TR><TD>fo_shared</TD><TD>prevent concurrent write access to the file</TD></TR>
</TABLE><P>
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD><code>file::lock_error</code> if <code>fo_exclusive</code> or <code>fo_shared</code> flags are specified and file was opened by some other process in 
incompatible mode;
<DD><DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="close"><pre>
iop_status close();
</pre></A>
<DL><DD>
Close the file.
<DL><DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="get_name"><pre>
char const* get_name();
</pre></A>
<DL><DD>
Get file name.
<DL><DT><B>Returns</B>
<DD>Name of the file.
</DL></DL>

<HR>
<A NAME="set_name"><pre>
iop_status set_name(char const* new_name);
</pre></A>
<DL><DD>
Rename the file.
<DL><DT><B>Parameters</B>
<DD><code>new_name</code> - new name for the file
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="get_size"><pre>
iop_status  get_size(fsize_t& size);
</pre></A>
<DL><DD>
Get file size.
<DL><DT><B>Parameters</B>
<DD><code>size</code> - reference of variable to hold file size.
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="set_size"><pre>
iop_status set_size(fsize_t new_size);
</pre></A>
<DL><DD>
Change file size.
<DL><DT><B>Parameters</B>
<DD><code>new_size</code> - new file size
<DT><B>Returns</B>
<DD><code>file::ok</code> if operation successfully completed; 
<DD>any other system dependent code if operation failed.
</DL></DL>

<HR>
<A NAME="get_error_text"><pre>
void get_error_text(iop_status code, char* buf, size_t buf_size)
</pre></A>
<DL><DD>
Get error message text for specified error code.
<DL><DT><B>Parameters</B>
<DD><code>code</code> - error code returned by some other file operation.
<DD><code>buf</code> - buffer to receive text of the error message
<DD><code>buf_size</code> - size of buffer, no more than <code>buf_size</code>
bytes will be placed in the buffer
</DL></DL>


<H3> <A NAME = "mmap_file">mmap_file</A></H3>
Mapped on memory file provides direct access to the file data using
virtual memory mechanism. That is the most efficient way to access
file, because it requires no context switching and data copying. 
This class provides all the methods from <code>os_file</code> class and has
one additional method <code>get_mmap_addr()</code>.<P>

<HR>
<pre>
mmap_file(const char* name, size_t init_size);
</pre></A>
<DL><DD>
Create mapped on memory file object with specified name.
<DL><DT><B>Parameters</B>
<DD><code>name</code> - name of the file
<DD><code>init_size</code> - initial size of the file. This method
will reserve at least init_size bytes of virtual memory and
map file on it. If the file size will exceed this value, then file will 
be reallocated. If the file size is greater than init_size, then this 
parameter is ignored. 
</DL></DL>

<HR>
<pre>
char* get_mmap_addr() const;
</pre></A>
<DL><DD>
Provide information about file mapping.
<DL><DT><B>Returns</B>
<DD>Starting address of virtual memory section where file is mapped,
</DL></DL>


<H3> <A NAME = "multifile">multifile</A></H3>
Class <code>multifile</code> can be used to overcome system limitation
for maximal file size or to distribute file space between several disk 
partitiones. This class implements all the methods described in
<A HREF="#osfile">os_file section</A>.<P>

<HR>
<pre>
multifile(int n_segments, segment* segments);
</pre></A>
<DL><DD>
Create file object consisting of several physical segments.
Each segment is described by <code>segment</code> structure declared
locally in <code>multifile</code> class and containing <code>name</code>
and <code>size</code> fields. Only file described in the last segment can be 
extended.
<DL><DT><B>Parameters</B>
<DD><code>n_segments</code> - number of segments in  multifile
<DD><code>segments</code> - pointer to the array of segment descriptions.
This array should have n_segments elements.
</DL></DL>



<H2> <A NAME = "sockets">Sockets</A></H2>
Abstract class socket has several derived classes providing
system dependent implementations of socket mechanism. 
To resolve name conflict this abstract socket class
was called <code>socket_t</code>. Concrete object implementing socket 
is create by static <code>create, accept</code> or <code>connect</code>
methods. Access to sockets should be synchronized by mutexes or some
other synchronization primitive. Concurrent execution of two read or two 
write operations can cause unpredictable behavior. But concurrent execution
of read and write operation is possible.<P>

Implementations of sockets are mostly based on socket library provided 
by operating system, but as far as local domain sockets are
supported only in Unix, SAL provides very efficient implementation
of local sockets for Win32. These local sockets are implemented by
Win32 shared memory and semaphore objects and can be used to perform
fast communication between processes within one computer. My experiments shows 
that this implementation of local sockets is about 10 times faster than
original socket library provided by Microsoft.<P>


<HR>
<A NAME="sock_read"><pre>
boolean read(void* buf, size_t size);
</pre></A>
<DL><DD>
Read data from socket.
<DL><DT><B>Parameters</B>
<DD><code>buf</code> - buffer to hold received data
<DD><code>buf_size</code> - number of bytes to receive
<DT><B>Returns</B>
<DD><code>True</code> if operation successfully completed, <code>False</code>
otherwise.
</DL></DL>

<HR>
<A NAME="sock_write"><pre>
boolean write(void const* buf, size_t size);
</pre></A>
<DL><DD>
Write data to socket.
<DL><DT><B>Parameters</B>
<DD><code>buf</code> - buffer containing data to send
<DD><code>buf_size</code> - number of bytes to send
<DT><B>Returns</B>
<DD><code>True</code> if operation successfully completed, <code>False</code>
otherwise.
</DL></DL>

<HR>
<A NAME="accept"><pre>
socket_t* accept();
</pre></A>
<DL><DD>
Accept new socket. This method is called by server to establish connection
with new client. When the client execute <code>connect</code> method and access
server's accept port, accept method will create new socket, which can be used
for communication with the client. Accept method will block current task until
some connection will be established.
<DL><DT><B>Returns</B>
<DD>Pointer to new socket or <code>NULL</code> if operation failed.
</DL></DL>

<HR>
<A NAME="cancel_accept"><pre>
boolean cancel_accept();
</pre></A>
<DL><DD>
Cancel accept operation. Task blocked in accept call be be awaken and continue
execution.
<DL><DT><B>Returns</B>
<DD><code>True</code> if socket was successfully closed, <code>False</code> 
otherwise.
</DL></DL>

<HR>
<A NAME="shutdown"><pre>
boolean shutdown();
</pre></A>
<DL><DD>
Shutdown the socket. This function prohibits write and read operation
on the socket. All future attempts to read or write data from/to the socket
will be refused. But all previously initiated operations are guaranteed to be 
completed. 
<DL><DT><B>Returns</B>
<DD><code>True</code> if operation successfully completed, <code>False</code> 
otherwise.
</DL></DL>


<HR>
<A NAME="close"><pre>
boolean close();
</pre></A>
<DL><DD>
Close connection.
<DL><DT><B>Returns</B>
<DD><code>True</code> if operation successfully completed, <code>False</code> 
otherwise.
</DL></DL>


<HR>
<A NAME="connect"><pre>
static socket_t*  connect(char const* address, 
      		          socket_domain domain = sock_any_domain, 
			  int max_attempts = DEFAULT_CONNECT_MAX_ATTEMPTS,
			  time_t timeout = DEFAULT_RECONNECT_TIMEOUT);
</pre></A>
<DL><DD>
Establish connection with server. This method will do at most
<code>max_attempts</code> attempts to connect server, with <code>timeout</code>
interval between attempts. 
<DL><DT><B>Parameters</B>
<DD><code>address</code> - address of server socket in format "hostname:port"
<DD><code>domain</code> - type of connection. The following values of this
parameter are recognized:<P>
<TABLE BORDER ALIGN="CENTER">
<TR><TH>Domain</TH><TH>Description</TH></TR>
<TR><TD>sock_any_domain</TD><TD>domain is chosen automatically</TD></TR>
<TR><TD>sock_local_domain</TD><TD>local domain (connection with one host)</TD></TR>
<TR><TD>sock_global_domain</TD><TD>internet domain</TD></TR>
</TABLE><P>

If sock_any_domain is specified, local connection is chosen when either
port was omitted in specification of the address or hostname is "localhost", 
and global connection is used in all other cases.

<DD><code>max_attempts</code> - maximal number of attempts to connect to server
<DD><code>timeout</code> - timeout in seconds between attempts to connect 
the server

<DT><B>Returns</B>
<DD>This method always create new socket object and returns pointer to it. 
If connection with server was not established, this socket contains error
code describing reason of failure. So returned socket should be first checked
by is_ok() method.
</DL></DL>


<HR>
<A NAME="create_local"><pre>
static socket_t* create_local(char const* address,
			      int listen_queue_size = 
				  DEFAULT_LISTEN_QUEUE_SIZE);

</pre></A>
<DL><DD>
Create and open socket in local domain at the server site.
<DL><DT><B>Parameters</B>
<DD><code>address</code> - address to be assigned to the socket
<DD><code>listen_queue_size</code> - size of listen queue
<DT><B>Returns</B>
<DD>This method always create new socket object and returns pointer to it. 
If socket can not be opened, error code field of returned socket describes the
reason of failure. 
So returned socket should be first checked by is_ok() method.
</DL></DL>

<HR>
<A NAME="create_global"><pre>
static socket_t* create_global(char const* address,
			      int listen_queue_size = 
				  DEFAULT_LISTEN_QUEUE_SIZE);

</pre></A>
<DL><DD>
Create and open socket in global (internet) domain at the server site.
<DL><DT><B>Parameters</B>
<DD><code>address</code> - address to be assigned to the socket
<DD><code>listen_queue_size</code> - size of listen queue
<DT><B>Returns</B>
<DD>This method always create new socket object and returns pointer to it. 
If socket can not be opened, error code field of returned socket describes 
the reason of failure. 
So returned socket should be first checked by is_ok() method.
</DL></DL>

<HR>
<A NAME="is_ok"><pre>
boolean is_ok();
</pre></A>
<DL><DD>
Check the status of the last operation with socket. 
<DL><DT><B>Returns</B>
<DD><code>True</code> if the last operation completed successfully, 
<code>False</code> otherwise
</DL></DL>

<HR>
<A NAME="sock_get_error_text"><pre>
void get_error_text(char* buf, size_t buf_size)
</pre></A>
<DL><DD>
Get error message text for the last operation.
<DL><DT><B>Parameters</B>
<DD><code>buf</code> - buffer to receive text of the error message
<DD><code>buf_size</code> - size of buffer, no more than <code>buf_size</code>
bytes will be placed in the buffer
</DL></DL>


<H2> <A NAME = "console">Console</A></H2>
SAL also contains abstraction of system console which provides your application
a system independent interface for reporting error/informational messages and
also organizing user dialogs. Default implementation of the console class uses
standard C input/output package (<code>printf(), scanf(),</code>...). 
Implementation of <code>input()</code> method provides concurrent IO with
cooperative multitasking library by multiplexing read operation by means of
<code>select()</code> function.<P>

A programmer can develop it own implementation of console class using
services of concrete window system. The class <code>console</code>
contains static field <code>active_console</code>, which points to the object
implementing console protocol. Static methods of class console invokes 
correspondent virtual methods of the object referenced by 
<code>active_console</code>. Console interface includes the following 
methods:<P>

<HR>
<A NAME="output"><pre>
static void output(const char* msg, ...); 
</pre></A>
<DL><DD>
Output message to the console.
<DL><DT><B>Parameters</B>
<DD><code>msg</code> - message text, which can contain the same output format 
sequences as <code>printf()</code> function. Zero or more extra arguments can 
be passed to this method to be used by correspondent conversion 
specifications. 
</DL></DL>


<HR>
<A NAME="error"><pre>
static void error(const char* msg, ...); 
</pre></A>
<DL><DD>
Output error message to the console and terminate application.
<DL><DT><B>Parameters</B>
<DD><code>msg</code> - message text, which can contain the same output format 
sequences as <code>printf()</code> function. Zero or more extra arguments can 
be passed to this method to be used by correspondent conversion 
specifications. 
</DL></DL>

<HR>
<A NAME="input"><pre>
static boolean input(char* buf, size_t buf_size);
</pre></A>
<DL><DD>
Read string from the console and place not more than <code>buf_size</code>
characters in input buffer. If length of string is greater than 
<code>buf_size</code>, then tails of the string will be kept in input queue.
If there is enough space in buffer, string will be terminated by '\0' symbol.
New line symbol is not removed from the buffer.
This operation will block only the current task
with all multitasking implementations.
<DL><DT><B>Parameters</B>
<DD><code>buf</code> - pointer to the buffer to receive input data;
<DD><code>buf_size</code> - size of input buffer
<DT><B>Returns</B>
<DD><code>true</code> if string was successfully read and placed in buffer,
<code>false</code> otherwise
</DL></DL><P>


Static methods <code>output</code> and <code>error</code> invoke virtual
method <code>output_data</code> of the active console object, and 
<code>input</code> static method invokes virtual method 
<code>input_data</code>:<P>


<HR>
<A NAME="output_data"><pre>
virtual void output_data(boolean error, const char* msg, va_list args);
</pre></A>
<DL><DD>
Output message to the console.
<DL><DT><B>Parameters</B>
<DD><code>error</code> - indicator of error message: <code>true</code> if error
is reported, <code>false</code> for normal messages;
<DD><code>msg</code> - message text with conversion patterns;
<DD><code>args</code> - arguments to be printed.
</DL></DL>

<HR>
<A NAME="input_data"><pre>
virtual boolean input_data(char* buf, size_t buf_size);
</pre></A>
<DL><DD>
Read string from the console and place not more than <code>buf_size</code>
characters in input buffer. If you redefine default implementation of this
method, do not forget about multiplexing read operations if you are using 
portable multitasking library. 
<DL><DT><B>Parameters</B>
<DD><code>buf</code> - pointer to the buffer to receive input data;
<DD><code>buf_size</code> - size of the input buffer.
<DT><B>Returns</B>
<DD><code>true</code> if string was successfully read and placed in buffer,
<code>false</code> otherwise
</DL></DL><P>
 
If you are using SAL portable multitasking implementation, you should
not use blocking system functions (such as <code>read(), write(), recv(), 
send()</code>) directly, otherwise all tasks in the process can be blocked by
this system call. You should only use methods of console and socket classes
provided by SAL. If you are using some other library, which is using sockets
(for example X-Windows), you should associate <code>unix_socket</code>
class with socket descriptor used in this library and invoke
<code>wait_input()</code> or <code>wait_ouput()</0code> socket methods
before read (write) operations. In X-Windows 
descriptor can be obtained by <code>XConnectioNumber()</code> function.<P>


<H2> <A NAME = "distribution">Distribution</A></H2>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the <A HREF="#Software">Software</A>), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:<P>

<A NAME="Software">
<B>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHOR OF THIS SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</B>
</A><P>

<HR>
<P ALIGN="CENTER"><A HREF="http://www.ispras.ru/~knizhnik">
<B>Look for new version at my homepage</B></A><B> | </B>
<A HREF="mailto:knizhnik@altavista.net">
<B>E-Mail me about bugs and problems</B></A></P>
</BODY>
</HTML>





